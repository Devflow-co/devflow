/**
 * Validation Utilities - Security validation for code generation
 *
 * Provides validation functions for:
 * - File paths (prevent path traversal)
 * - Branch names (prevent injection)
 * - Commit messages (sanitization)
 * - File content (size limits)
 */

import { createLogger } from '@devflow/common';

const logger = createLogger('ValidationUtils');

// ============================================
// Constants
// ============================================

/** Maximum allowed file size in bytes (1MB) */
export const MAX_FILE_SIZE_BYTES = 1 * 1024 * 1024;

/** Maximum file path length */
export const MAX_FILE_PATH_LENGTH = 500;

/** Maximum branch name length */
export const MAX_BRANCH_NAME_LENGTH = 255;

/** Maximum commit message length */
export const MAX_COMMIT_MESSAGE_LENGTH = 5000;

/** Allowed file extensions for code generation */
export const ALLOWED_FILE_EXTENSIONS = new Set([
  // TypeScript/JavaScript
  'ts', 'tsx', 'js', 'jsx', 'mjs', 'cjs',
  // Config files
  'json', 'yaml', 'yml', 'toml',
  // Styles
  'css', 'scss', 'sass', 'less',
  // Markup
  'html', 'md', 'mdx',
  // Other languages
  'py', 'go', 'rs', 'java', 'kt', 'rb', 'php', 'cs', 'cpp', 'c', 'h', 'hpp',
  // Shell
  'sh', 'bash', 'zsh',
  // SQL
  'sql',
  // GraphQL
  'graphql', 'gql',
  // Env examples
  'example', 'sample',
  // Lock files
  'lock',
  // Vue/Svelte
  'vue', 'svelte',
  // Prisma
  'prisma',
]);

/** Dangerous paths that should never be modified */
const DANGEROUS_PATHS = [
  '/etc/',
  '/usr/',
  '/bin/',
  '/sbin/',
  '/var/',
  '/tmp/',
  '/root/',
  '/home/',
  '~/',
  'node_modules/',
  '.git/',
  '.env',
  '.env.local',
  '.env.production',
  '.env.development',
  'credentials',
  'secrets',
  'private',
  'id_rsa',
  'id_ed25519',
  '.ssh/',
  '.aws/',
  '.npmrc',
  '.yarnrc',
];

/** Patterns that indicate path traversal attempts */
const PATH_TRAVERSAL_PATTERNS = [
  /\.\./,           // Parent directory traversal
  /\/\.\.\//,       // Hidden traversal
  /^\.\.$/,         // Just ..
  /\\\.\\./,        // Windows style
  /%2e%2e/i,        // URL encoded
  /%252e%252e/i,    // Double URL encoded
  /\.{3,}/,         // Multiple dots
  /^\/+/,           // Absolute paths starting with /
  /^[a-zA-Z]:\\/,   // Windows absolute paths (C:\)
  /\0/,             // Null bytes
];

// ============================================
// File Path Validation
// ============================================

export interface FilePathValidationResult {
  valid: boolean;
  normalizedPath: string;
  error?: string;
}

/**
 * Validate and normalize a file path generated by LLM
 *
 * Security checks:
 * - No path traversal (..)
 * - No absolute paths
 * - No dangerous system paths
 * - Allowed file extensions only
 * - Reasonable length
 */
export function validateFilePath(path: string): FilePathValidationResult {
  // Null/empty check
  if (!path || typeof path !== 'string') {
    return {
      valid: false,
      normalizedPath: '',
      error: 'File path is empty or invalid',
    };
  }

  // Trim whitespace
  const trimmedPath = path.trim();

  // Length check
  if (trimmedPath.length > MAX_FILE_PATH_LENGTH) {
    return {
      valid: false,
      normalizedPath: '',
      error: `File path exceeds maximum length of ${MAX_FILE_PATH_LENGTH} characters`,
    };
  }

  // Check for path traversal patterns
  for (const pattern of PATH_TRAVERSAL_PATTERNS) {
    if (pattern.test(trimmedPath)) {
      logger.warn('Path traversal attempt detected', { path: trimmedPath, pattern: pattern.toString() });
      return {
        valid: false,
        normalizedPath: '',
        error: 'Path traversal detected - paths must not contain ".." or absolute paths',
      };
    }
  }

  // Check for dangerous paths
  const lowerPath = trimmedPath.toLowerCase();
  for (const dangerous of DANGEROUS_PATHS) {
    if (lowerPath.includes(dangerous.toLowerCase())) {
      logger.warn('Dangerous path detected', { path: trimmedPath, dangerous });
      return {
        valid: false,
        normalizedPath: '',
        error: `Path contains dangerous location: ${dangerous}`,
      };
    }
  }

  // Normalize path (remove leading ./ and duplicate slashes)
  let normalizedPath = trimmedPath
    .replace(/^\.\/+/, '')           // Remove leading ./
    .replace(/\/+/g, '/')            // Replace multiple slashes with single
    .replace(/\/$/g, '');            // Remove trailing slash

  // Check file extension
  const extension = normalizedPath.split('.').pop()?.toLowerCase();
  if (extension && !ALLOWED_FILE_EXTENSIONS.has(extension)) {
    // Allow extensionless files like Dockerfile, Makefile
    const filename = normalizedPath.split('/').pop()?.toLowerCase() || '';
    const allowedExtensionlessFiles = ['dockerfile', 'makefile', 'jenkinsfile', 'procfile', 'readme', 'license', 'changelog'];
    if (!allowedExtensionlessFiles.includes(filename)) {
      logger.warn('Disallowed file extension', { path: normalizedPath, extension });
      return {
        valid: false,
        normalizedPath: '',
        error: `File extension ".${extension}" is not allowed for code generation`,
      };
    }
  }

  return {
    valid: true,
    normalizedPath,
  };
}

/**
 * Validate an array of file paths, returning only valid ones
 */
export function validateFilePaths(paths: string[]): {
  valid: Array<{ original: string; normalized: string }>;
  invalid: Array<{ path: string; error: string }>;
} {
  const valid: Array<{ original: string; normalized: string }> = [];
  const invalid: Array<{ path: string; error: string }> = [];

  for (const path of paths) {
    const result = validateFilePath(path);
    if (result.valid) {
      valid.push({ original: path, normalized: result.normalizedPath });
    } else {
      invalid.push({ path, error: result.error || 'Unknown validation error' });
    }
  }

  if (invalid.length > 0) {
    logger.warn('Some file paths failed validation', {
      validCount: valid.length,
      invalidCount: invalid.length,
      invalidPaths: invalid.map(i => i.path),
    });
  }

  return { valid, invalid };
}

// ============================================
// Branch Name Validation
// ============================================

export interface BranchNameValidationResult {
  valid: boolean;
  sanitizedName: string;
  error?: string;
}

/**
 * Validate and sanitize a branch name
 *
 * Security checks:
 * - No shell metacharacters
 * - No control characters
 * - Alphanumeric with hyphens, underscores, and forward slashes
 * - Reasonable length
 */
export function validateBranchName(branchName: string): BranchNameValidationResult {
  if (!branchName || typeof branchName !== 'string') {
    return {
      valid: false,
      sanitizedName: '',
      error: 'Branch name is empty or invalid',
    };
  }

  const trimmed = branchName.trim();

  // Length check
  if (trimmed.length > MAX_BRANCH_NAME_LENGTH) {
    return {
      valid: false,
      sanitizedName: '',
      error: `Branch name exceeds maximum length of ${MAX_BRANCH_NAME_LENGTH} characters`,
    };
  }

  // Sanitize: keep only allowed characters
  // Allowed: alphanumeric, hyphens, underscores, forward slashes
  const sanitized = trimmed
    .replace(/[^a-zA-Z0-9\-_\/]/g, '-')  // Replace disallowed chars with hyphens
    .replace(/-+/g, '-')                   // Replace multiple hyphens with single
    .replace(/^-+|-+$/g, '')               // Remove leading/trailing hyphens
    .replace(/\/+/g, '/')                  // Replace multiple slashes with single
    .replace(/^\/+|\/+$/g, '');            // Remove leading/trailing slashes

  // Git branch name restrictions
  if (sanitized.includes('..')) {
    return {
      valid: false,
      sanitizedName: '',
      error: 'Branch name cannot contain ".."',
    };
  }

  if (sanitized.startsWith('-') || sanitized.endsWith('.lock')) {
    return {
      valid: false,
      sanitizedName: '',
      error: 'Invalid branch name format',
    };
  }

  // Ensure branch name is not empty after sanitization
  if (!sanitized) {
    return {
      valid: false,
      sanitizedName: '',
      error: 'Branch name is empty after sanitization',
    };
  }

  return {
    valid: true,
    sanitizedName: sanitized,
  };
}

/**
 * Generate a safe branch name from a task identifier and title
 */
export function generateSafeBranchName(
  taskIdentifier: string,
  title: string,
  prefix: string = 'feat'
): string {
  // Clean the task identifier
  const cleanIdentifier = taskIdentifier
    .toLowerCase()
    .replace(/[^a-z0-9]/g, '-')
    .replace(/-+/g, '-')
    .substring(0, 20);

  // Clean the title
  const cleanTitle = title
    .toLowerCase()
    .replace(/[^a-z0-9\s]/g, '')
    .replace(/\s+/g, '-')
    .substring(0, 40);

  const branchName = `${prefix}/${cleanIdentifier}-${cleanTitle}`.replace(/-+/g, '-').replace(/-$/, '');

  return branchName;
}

// ============================================
// Commit Message Sanitization
// ============================================

/**
 * Sanitize a commit message to prevent injection
 */
export function sanitizeCommitMessage(message: string): string {
  if (!message || typeof message !== 'string') {
    return 'chore: generated changes';
  }

  let sanitized = message.trim();

  // Truncate if too long
  if (sanitized.length > MAX_COMMIT_MESSAGE_LENGTH) {
    sanitized = sanitized.substring(0, MAX_COMMIT_MESSAGE_LENGTH - 3) + '...';
  }

  // Remove control characters except newlines
  sanitized = sanitized.replace(/[\x00-\x09\x0b-\x1f\x7f]/g, '');

  // Escape shell metacharacters in the first line (summary)
  const lines = sanitized.split('\n');
  lines[0] = lines[0].replace(/[`$\\]/g, '');

  return lines.join('\n');
}

// ============================================
// File Content Validation
// ============================================

export interface FileContentValidationResult {
  valid: boolean;
  truncated: boolean;
  content: string;
  error?: string;
}

/**
 * Validate file content size and optionally truncate
 */
export function validateFileContent(
  content: string,
  maxSize: number = MAX_FILE_SIZE_BYTES
): FileContentValidationResult {
  if (!content || typeof content !== 'string') {
    return {
      valid: true,
      truncated: false,
      content: '',
    };
  }

  const size = Buffer.byteLength(content, 'utf8');

  if (size > maxSize) {
    logger.warn('File content exceeds maximum size', { size, maxSize });
    return {
      valid: false,
      truncated: true,
      content: content.substring(0, maxSize),
      error: `File content exceeds maximum size of ${maxSize} bytes`,
    };
  }

  return {
    valid: true,
    truncated: false,
    content,
  };
}

// ============================================
// Token Estimation
// ============================================

/**
 * Estimate token count for text (approximation: ~4 chars per token)
 */
export function estimateTokens(text: string): number {
  if (!text) return 0;
  return Math.ceil(text.length / 4);
}

/**
 * Truncate content to fit within token budget
 */
export function truncateToTokenBudget(
  content: string,
  maxTokens: number,
  suffix: string = '\n... [truncated]'
): { content: string; truncated: boolean; estimatedTokens: number } {
  const estimated = estimateTokens(content);

  if (estimated <= maxTokens) {
    return { content, truncated: false, estimatedTokens: estimated };
  }

  // Approximate character limit based on token budget
  const charLimit = maxTokens * 4 - suffix.length;
  const truncated = content.substring(0, charLimit) + suffix;

  return {
    content: truncated,
    truncated: true,
    estimatedTokens: maxTokens,
  };
}

/**
 * Budget tokens across multiple content sections
 *
 * @param sections Array of content sections with priorities (lower = higher priority)
 * @param totalBudget Total token budget
 * @returns Sections with content truncated to fit budget
 */
export function budgetTokensAcrossSections(
  sections: Array<{ id: string; content: string; priority: number; minTokens?: number }>,
  totalBudget: number
): Array<{ id: string; content: string; allocatedTokens: number; truncated: boolean }> {
  // Sort by priority (lower first = higher priority)
  const sorted = [...sections].sort((a, b) => a.priority - b.priority);

  const results: Array<{ id: string; content: string; allocatedTokens: number; truncated: boolean }> = [];
  let remainingBudget = totalBudget;

  for (const section of sorted) {
    const estimated = estimateTokens(section.content);
    const minTokens = section.minTokens || 0;

    // Calculate allocation
    let allocated: number;
    if (estimated <= remainingBudget) {
      allocated = estimated;
    } else if (remainingBudget >= minTokens) {
      allocated = remainingBudget;
    } else {
      allocated = 0;
    }

    if (allocated > 0) {
      const result = truncateToTokenBudget(section.content, allocated);
      results.push({
        id: section.id,
        content: result.content,
        allocatedTokens: result.estimatedTokens,
        truncated: result.truncated,
      });
      remainingBudget -= result.estimatedTokens;
    } else {
      results.push({
        id: section.id,
        content: '',
        allocatedTokens: 0,
        truncated: true,
      });
    }
  }

  return results;
}
