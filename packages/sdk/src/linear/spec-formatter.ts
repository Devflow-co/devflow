/**
 * Spec Formatter for Linear - Formats technical specifications as markdown
 */

import {
  SpecGenerationOutput,
  RefinementOutput,
  UserStoryGenerationOutput,
  TechnicalPlanGenerationOutput,
  CouncilSummary,
} from '@devflow/common';

/**
 * Format a technical specification as markdown for Linear
 */
export function formatSpecAsMarkdown(spec: SpecGenerationOutput): string {
  const sections: string[] = [];

  // Header
  sections.push('# Technical Specification');
  sections.push('');
  sections.push('> Generated by DevFlow');
  sections.push('');

  // Architecture
  if (spec.architecture && spec.architecture.length > 0) {
    sections.push('## Architecture Decisions');
    sections.push('');
    spec.architecture.forEach((decision, i) => {
      sections.push(`${i + 1}. ${decision}`);
    });
    sections.push('');
  }

  // Implementation Steps
  if (spec.implementationSteps && spec.implementationSteps.length > 0) {
    sections.push('## Implementation Steps');
    sections.push('');
    spec.implementationSteps.forEach((step, i) => {
      sections.push(`${i + 1}. ${step}`);
    });
    sections.push('');
  }

  // Technical Decisions
  if (spec.technicalDecisions && spec.technicalDecisions.length > 0) {
    sections.push('## Technical Decisions');
    sections.push('');
    spec.technicalDecisions.forEach((decision) => {
      sections.push(`- ${decision}`);
    });
    sections.push('');
  }

  // Dependencies
  if (spec.dependencies && spec.dependencies.length > 0) {
    sections.push('## Dependencies');
    sections.push('');
    spec.dependencies.forEach((dep) => {
      sections.push(`- ${dep}`);
    });
    sections.push('');
  }

  // Testing Strategy
  if (spec.testingStrategy) {
    sections.push('## Testing Strategy');
    sections.push('');
    sections.push(spec.testingStrategy);
    sections.push('');
  }

  // Risks
  if (spec.risks && spec.risks.length > 0) {
    sections.push('## Risks & Considerations');
    sections.push('');
    spec.risks.forEach((risk) => {
      sections.push(`- âš ï¸ ${risk}`);
    });
    sections.push('');
  }

  // Estimated Time
  if (spec.estimatedTime) {
    sections.push('## Estimated Time');
    sections.push('');
    const hours = Math.floor(spec.estimatedTime / 60);
    const minutes = spec.estimatedTime % 60;
    if (hours > 0) {
      sections.push(`~${hours} hour${hours > 1 ? 's' : ''} ${minutes > 0 ? `${minutes} minutes` : ''}`);
    } else {
      sections.push(`~${minutes} minutes`);
    }
    sections.push('');
  }

  return sections.join('\n');
}

/**
 * Format a warning message for Linear (as a quote block)
 */
export function formatWarningMessage(message?: string): string {
  const warningText = message || 'This specification was generated by DevFlow. Please review before implementation.';
  return `> âš ï¸ **AI-Generated Content**\n>\n> ${warningText}`;
}

/**
 * Format spec with warning header
 */
export function formatSpecWithWarning(spec: SpecGenerationOutput, warningMessage?: string): string {
  const warning = formatWarningMessage(warningMessage);
  const specMarkdown = formatSpecAsMarkdown(spec);

  return `${warning}\n\n---\n\n${specMarkdown}`;
}

// ============================================
// Three-Phase Agile Workflow Formatters
// ============================================

/**
 * Format refinement output as markdown for Linear
 * Phase 1 of Three-Phase Agile Workflow
 */
export function formatRefinementAsMarkdown(refinement: RefinementOutput): string {
  const sections: string[] = [];

  // Header
  sections.push('# Backlog Refinement');
  sections.push('');
  sections.push('> Generated by DevFlow - Phase 1: Refinement');
  sections.push('');

  // Task Type Badge
  const typeEmojis = {
    feature: 'âœ¨',
    bug: 'ðŸ›',
    enhancement: 'ðŸ”§',
    chore: 'ðŸ§¹',
  };
  sections.push(`**Type:** ${typeEmojis[refinement.taskType]} ${refinement.taskType.toUpperCase()}`);
  sections.push('');

  // Business Context
  if (refinement.businessContext) {
    sections.push('## Business Context');
    sections.push('');
    sections.push(refinement.businessContext);
    sections.push('');
  }

  // Objectives
  if (refinement.objectives && refinement.objectives.length > 0) {
    sections.push('## Objectives');
    sections.push('');
    refinement.objectives.forEach((objective, i) => {
      sections.push(`${i + 1}. ${objective}`);
    });
    sections.push('');
  }

  // Preliminary Acceptance Criteria
  if (refinement.preliminaryAcceptanceCriteria && refinement.preliminaryAcceptanceCriteria.length > 0) {
    sections.push('## Preliminary Acceptance Criteria');
    sections.push('');
    refinement.preliminaryAcceptanceCriteria.forEach((criterion, i) => {
      sections.push(`${i + 1}. ${criterion}`);
    });
    sections.push('');
  }

  // Questions for Product Owner
  if (refinement.questionsForPO && refinement.questionsForPO.length > 0) {
    sections.push('## â“ Questions for Product Owner');
    sections.push('');
    refinement.questionsForPO.forEach((question) => {
      sections.push(`- ${question}`);
    });
    sections.push('');
  }

  // Suggested Split
  if (refinement.suggestedSplit) {
    sections.push('## ðŸ”€ Suggested Split');
    sections.push('');
    sections.push(`**Reason:** ${refinement.suggestedSplit.reason}`);
    sections.push('');
    sections.push('**Proposed Stories:**');
    sections.push('');

    refinement.suggestedSplit.proposedStories.forEach((story, i) => {
      sections.push(`### ${i + 1}. ${story.title}`);
      sections.push('');
      sections.push(story.description);
      sections.push('');

      // Dependencies
      if (story.dependencies && story.dependencies.length > 0) {
        sections.push('**Dependencies:**');
        story.dependencies.forEach((depIndex) => {
          const depTitle =
            refinement.suggestedSplit!.proposedStories[depIndex]?.title || `Subtask ${depIndex + 1}`;
          sections.push(`- Depends on: ${depTitle}`);
        });
        sections.push('');
      }

      // Acceptance Criteria
      if (story.acceptanceCriteria && story.acceptanceCriteria.length > 0) {
        sections.push('**Acceptance Criteria:**');
        story.acceptanceCriteria.forEach((criterion, idx) => {
          sections.push(`${idx + 1}. ${criterion}`);
        });
        sections.push('');
      }
    });
    sections.push('');
  }

  // Complexity Estimate
  const sizeEmojis = {
    XS: 'âšª',
    S: 'ðŸŸ¢',
    M: 'ðŸŸ¡',
    L: 'ðŸŸ ',
    XL: 'ðŸ”´',
  };
  sections.push('## Complexity Estimate');
  sections.push('');
  sections.push(`${sizeEmojis[refinement.complexityEstimate]} **${refinement.complexityEstimate}** (T-shirt sizing)`);
  sections.push('');

  return sections.join('\n');
}

/**
 * Format user story output as markdown for Linear
 * Phase 2 of Three-Phase Agile Workflow
 */
export function formatUserStoryAsMarkdown(story: UserStoryGenerationOutput): string {
  const sections: string[] = [];

  // Header
  sections.push('# User Story');
  sections.push('');
  sections.push('> Generated by DevFlow - Phase 2: User Story');
  sections.push('');

  // User Story Format
  sections.push('## Story');
  sections.push('');
  sections.push(`**As a** ${story.userStory.actor},`);
  sections.push(`**I want** ${story.userStory.goal},`);
  sections.push(`**So that** ${story.userStory.benefit}.`);
  sections.push('');

  // Business Value
  if (story.businessValue) {
    sections.push('## Business Value');
    sections.push('');
    sections.push(story.businessValue);
    sections.push('');
  }

  // Acceptance Criteria
  if (story.acceptanceCriteria && story.acceptanceCriteria.length > 0) {
    sections.push('## Acceptance Criteria');
    sections.push('');
    story.acceptanceCriteria.forEach((criterion, i) => {
      sections.push(`${i + 1}. ${criterion}`);
    });
    sections.push('');
  }

  // Definition of Done
  if (story.definitionOfDone && story.definitionOfDone.length > 0) {
    sections.push('## Definition of Done');
    sections.push('');
    story.definitionOfDone.forEach((item) => {
      sections.push(`- ${item}`);
    });
    sections.push('');
  }

  // Story Points
  sections.push('## Estimated Complexity');
  sections.push('');
  sections.push(`**Story Points:** ${story.storyPoints} (Fibonacci scale)`);
  sections.push('');

  return sections.join('\n');
}

/**
 * Format technical plan output as markdown for Linear
 * Phase 3 of Three-Phase Agile Workflow
 */
export function formatTechnicalPlanAsMarkdown(plan: TechnicalPlanGenerationOutput): string {
  const sections: string[] = [];

  // Header
  sections.push('# Technical Implementation Plan');
  sections.push('');
  sections.push('> Generated by DevFlow - Phase 3: Technical Plan');
  sections.push('');

  // Architecture Decisions
  if (plan.architecture && plan.architecture.length > 0) {
    sections.push('## Architecture Decisions');
    sections.push('');
    plan.architecture.forEach((decision, i) => {
      sections.push(`${i + 1}. ${decision}`);
    });
    sections.push('');
  }

  // Files Affected
  if (plan.filesAffected && plan.filesAffected.length > 0) {
    sections.push('## Files to Modify');
    sections.push('');
    plan.filesAffected.forEach((file) => {
      sections.push(`- \`${file}\``);
    });
    sections.push('');
  }

  // Implementation Steps
  if (plan.implementationSteps && plan.implementationSteps.length > 0) {
    sections.push('## Implementation Steps');
    sections.push('');
    plan.implementationSteps.forEach((step, i) => {
      sections.push(`${i + 1}. ${step}`);
    });
    sections.push('');
  }

  // Technical Decisions
  if (plan.technicalDecisions && plan.technicalDecisions.length > 0) {
    sections.push('## Technical Decisions');
    sections.push('');
    plan.technicalDecisions.forEach((decision) => {
      sections.push(`- ${decision}`);
    });
    sections.push('');
  }

  // Dependencies
  if (plan.dependencies && plan.dependencies.length > 0) {
    sections.push('## Dependencies');
    sections.push('');
    plan.dependencies.forEach((dep) => {
      sections.push(`- ${dep}`);
    });
    sections.push('');
  }

  // Testing Strategy
  if (plan.testingStrategy) {
    sections.push('## Testing Strategy');
    sections.push('');
    sections.push(plan.testingStrategy);
    sections.push('');
  }

  // Risks & Considerations
  if (plan.risks && plan.risks.length > 0) {
    sections.push('## Risks & Considerations');
    sections.push('');
    plan.risks.forEach((risk) => {
      sections.push(`- âš ï¸ ${risk}`);
    });
    sections.push('');
  }

  // Estimated Time
  if (plan.estimatedTime) {
    sections.push('## Estimated Time');
    sections.push('');
    const hours = Math.floor(plan.estimatedTime / 60);
    const minutes = plan.estimatedTime % 60;
    if (hours > 0) {
      sections.push(`~${hours}h ${minutes > 0 ? `${minutes}m` : ''}`);
    } else {
      sections.push(`~${minutes}m`);
    }
    sections.push('');
  }

  return sections.join('\n');
}

// ============================================
// LLM Council Formatter
// ============================================

/**
 * Format council deliberation summary as markdown for Linear
 * Appended to phase outputs when council mode is enabled
 * Uses blockquote styling for visual distinction
 */
export function formatCouncilSummaryAsMarkdown(summary: CouncilSummary): string {
  const sections: string[] = [];

  // Visual separator and header
  sections.push('');
  sections.push('---');
  sections.push('');
  sections.push('### ðŸ§  LLM Council Deliberation');
  sections.push('');

  // Blockquote box for the council info
  sections.push('> **Multi-Model Analysis**');
  sections.push('> ');
  sections.push('> This output was synthesized through a 3-stage deliberation process:');
  sections.push('> 1. Parallel generation from multiple LLMs');
  sections.push('> 2. Anonymized peer ranking (each model ranks others)');
  sections.push('> 3. Chairman synthesis of top-ranked insights');
  sections.push('');

  // Council composition in a compact format
  const modelNames = summary.councilModels.map(m => m.split('/')[1] || m);
  const chairmanShort = summary.chairmanModel.split('/')[1] || summary.chairmanModel;
  sections.push(`**Council:** ${modelNames.join(', ')} | **Chairman:** ${chairmanShort}`);
  sections.push('');

  // Peer rankings - ensure it's displayed prominently
  sections.push('#### Peer Rankings');
  sections.push('');
  sections.push(summary.rankingSummary);
  sections.push('');

  // Agreement and top model in a summary line
  const agreementEmoji =
    summary.agreementLevel === 'high'
      ? 'ðŸŸ¢ HIGH'
      : summary.agreementLevel === 'medium'
        ? 'ðŸŸ¡ MEDIUM'
        : 'ðŸ”´ LOW';
  const topRankedShort = summary.topRankedModel.split('/')[1] || summary.topRankedModel;

  sections.push(`**Agreement:** ${agreementEmoji} | **Top Ranked:** ${topRankedShort}`);
  sections.push('');

  // Synthesis explanation in blockquote
  sections.push('#### Synthesis Notes');
  sections.push('');
  sections.push(`> ${summary.synthesisExplanation}`);
  sections.push('');

  return sections.join('\n');
}

// ============================================
// DevFlow Master Description Structure
// ============================================

/**
 * Marker used to identify DevFlow-generated content in Linear descriptions
 */
const DEVFLOW_MARKER = '# DevFlow Analysis';

/**
 * Phase section markers for parsing
 * Note: Linear's >>> collapsible syntax is NOT supported via API
 * Using standard markdown headers with visual separators instead
 */
const PHASE_MARKERS = {
  refinement: {
    start: '## 1ï¸âƒ£ Phase 1: Backlog Refinement',
    end: '---',
  },
  userStory: {
    start: '## 2ï¸âƒ£ Phase 2: User Story',
    end: '---',
  },
  technicalPlan: {
    start: '## 3ï¸âƒ£ Phase 3: Technical Plan',
    end: '---',
  },
};

/**
 * Parsed DevFlow description structure
 */
export interface ParsedDevFlowDescription {
  originalDescription: string;
  hasRefinement: boolean;
  hasUserStory: boolean;
  hasTechnicalPlan: boolean;
  refinementContent?: string;
  userStoryContent?: string;
  technicalPlanContent?: string;
}

/**
 * Input parts for building a DevFlow description
 */
export interface DevFlowDescriptionParts {
  originalDescription: string;
  refinement?: {
    content: string;
    councilSummary?: CouncilSummary;
  };
  userStory?: {
    content: string;
    councilSummary?: CouncilSummary;
  };
  technicalPlan?: {
    content: string;
    councilSummary?: CouncilSummary;
    contextUsed?: {
      language: string;
      framework?: string;
      dependencies: number;
      conventions: number;
      filesAnalyzed: string[];
      usingRAG: boolean;
    };
    bestPractices?: {
      bestPractices: string;
      perplexityModel: string;
    };
  };
  /**
   * Links to Linear Documents for each phase
   * Used when phases are stored as separate documents linked to the issue
   */
  documentLinks?: {
    codebaseContext?: string;
    userStory?: string;
    technicalPlan?: string;
    bestPractices?: string;
  };
}

/**
 * Parse an existing Linear description to extract DevFlow content
 * Used to preserve existing phases when adding new ones
 */
export function parseDevFlowDescription(description: string): ParsedDevFlowDescription {
  // Check if description has DevFlow content
  const devflowIndex = description.indexOf(DEVFLOW_MARKER);

  if (devflowIndex === -1) {
    // No DevFlow content yet - entire description is original
    return {
      originalDescription: description.trim(),
      hasRefinement: false,
      hasUserStory: false,
      hasTechnicalPlan: false,
    };
  }

  // Extract original description (before the divider and DevFlow marker)
  // Look for "___" or "---" before the marker
  let originalDescription = description.substring(0, devflowIndex);
  originalDescription = originalDescription.replace(/\n*[_-]{3,}\n*$/, '').trim();

  // Extract phase contents using regex
  const refinementMatch = extractPhaseContent(description, PHASE_MARKERS.refinement);
  const userStoryMatch = extractPhaseContent(description, PHASE_MARKERS.userStory);
  const technicalPlanMatch = extractPhaseContent(description, PHASE_MARKERS.technicalPlan);

  return {
    originalDescription,
    hasRefinement: !!refinementMatch,
    hasUserStory: !!userStoryMatch,
    hasTechnicalPlan: !!technicalPlanMatch,
    refinementContent: refinementMatch,
    userStoryContent: userStoryMatch,
    technicalPlanContent: technicalPlanMatch,
  };
}

/**
 * Extract content between phase markers
 * Looks for content between the start header and either:
 * - The next phase header (## 1ï¸âƒ£, ## 2ï¸âƒ£, ## 3ï¸âƒ£)
 * - A horizontal rule followed by another section
 * - End of content
 */
function extractPhaseContent(
  description: string,
  markers: { start: string; end: string }
): string | undefined {
  const startIndex = description.indexOf(markers.start);
  if (startIndex === -1) return undefined;

  // Find the content start (after the marker line)
  const contentStart = startIndex + markers.start.length;
  const afterStart = description.substring(contentStart);

  // Find the end: next phase header or end of DevFlow content
  // Look for next "## 1ï¸âƒ£", "## 2ï¸âƒ£", "## 3ï¸âƒ£" or end of string
  const nextPhaseMatch = afterStart.match(/\n## [123]ï¸âƒ£ Phase/);

  let content: string;
  if (nextPhaseMatch && nextPhaseMatch.index !== undefined) {
    content = afterStart.substring(0, nextPhaseMatch.index);
  } else {
    content = afterStart;
  }

  // Remove trailing --- if present
  content = content.replace(/\n---\s*$/, '').trim();

  return content || undefined;
}

/**
 * Format the complete DevFlow description with progress summary and document links
 *
 * New architecture (v2.3.0):
 * - Refinement (Phase 1) stays in the issue description
 * - User Story (Phase 2) is stored in a separate Linear Document (linked via issueId)
 * - Technical Plan (Phase 3) is stored in a separate Linear Document (linked via issueId)
 * - Document links are added to the description for quick navigation
 */
export function formatDevFlowDescription(parts: DevFlowDescriptionParts): string {
  const sections: string[] = [];

  // Part 1: Original description (always first)
  if (parts.originalDescription) {
    sections.push(parts.originalDescription);
    sections.push('');
  }

  // Part 2: Divider and DevFlow header
  sections.push('___');
  sections.push('');
  sections.push(DEVFLOW_MARKER);
  sections.push('');

  // Part 3: Progress summary - check documents OR inline content
  const hasUserStory = !!parts.userStory || !!parts.documentLinks?.userStory;
  const hasTechnicalPlan = !!parts.technicalPlan || !!parts.documentLinks?.technicalPlan;

  const phases = [
    { name: 'Refinement', exists: !!parts.refinement, num: '1ï¸âƒ£' },
    { name: 'User Story', exists: hasUserStory, num: '2ï¸âƒ£' },
    { name: 'Technical Plan', exists: hasTechnicalPlan, num: '3ï¸âƒ£' },
  ];

  sections.push('**Progress:** ' + phases.map((p) => {
    if (p.exists) {
      return `${p.num} ${p.name} âœ“`;
    }
    return `${p.num} ~~${p.name}~~`;
  }).join(' â†’ '));
  sections.push('');

  // Part 4: Document links section (if documents exist)
  if (parts.documentLinks?.codebaseContext || parts.documentLinks?.userStory || parts.documentLinks?.technicalPlan || parts.documentLinks?.bestPractices) {
    sections.push('');
    sections.push('## ðŸ“„ Documents');
    sections.push('');
    if (parts.documentLinks.codebaseContext) {
      sections.push(`- [ðŸ“‚ Codebase Context](${parts.documentLinks.codebaseContext})`);
    }
    if (parts.documentLinks.userStory) {
      sections.push(`- [ðŸ“ User Story](${parts.documentLinks.userStory})`);
    }
    if (parts.documentLinks.bestPractices) {
      sections.push(`- [ðŸ’¡ Best Practices](${parts.documentLinks.bestPractices})`);
    }
    if (parts.documentLinks.technicalPlan) {
      sections.push(`- [ðŸ”§ Technical Plan](${parts.documentLinks.technicalPlan})`);
    }
    sections.push('');
  }

  // Part 5: Phase 1 - Refinement (always in description)
  if (parts.refinement) {
    sections.push('');
    sections.push(PHASE_MARKERS.refinement.start);
    sections.push('');
    sections.push(parts.refinement.content);

    if (parts.refinement.councilSummary) {
      sections.push('');
      sections.push(formatCouncilSummaryAsMarkdown(parts.refinement.councilSummary));
    }

    sections.push('');
  }

  // Part 6: Phase 2 - User Story (legacy: inline content when not using documents)
  // Only include if content is provided AND no document link exists
  if (parts.userStory && !parts.documentLinks?.userStory) {
    sections.push(PHASE_MARKERS.userStory.start);
    sections.push('');
    sections.push(parts.userStory.content);

    if (parts.userStory.councilSummary) {
      sections.push('');
      sections.push(formatCouncilSummaryAsMarkdown(parts.userStory.councilSummary));
    }

    sections.push('');
  }

  // Part 7: Phase 3 - Technical Plan (legacy: inline content when not using documents)
  // Only include if content is provided AND no document link exists
  if (parts.technicalPlan && !parts.documentLinks?.technicalPlan) {
    sections.push(PHASE_MARKERS.technicalPlan.start);
    sections.push('');
    sections.push(parts.technicalPlan.content);

    // Add codebase context if provided
    if (parts.technicalPlan.contextUsed) {
      sections.push('');
      sections.push('#### ðŸ” Codebase Context');
      sections.push('');
      sections.push(`**Language:** ${parts.technicalPlan.contextUsed.language}`);
      if (parts.technicalPlan.contextUsed.framework) {
        sections.push(`**Framework:** ${parts.technicalPlan.contextUsed.framework}`);
      }
      sections.push(`**Dependencies analyzed:** ${parts.technicalPlan.contextUsed.dependencies}`);
      sections.push(`**Conventions found:** ${parts.technicalPlan.contextUsed.conventions}`);
      sections.push(`**Using RAG:** ${parts.technicalPlan.contextUsed.usingRAG ? 'Yes' : 'No'}`);

      if (parts.technicalPlan.contextUsed.filesAnalyzed?.length > 0) {
        sections.push('');
        sections.push('**Referenced files:**');
        parts.technicalPlan.contextUsed.filesAnalyzed.slice(0, 10).forEach((file) => {
          sections.push(`- \`${file}\``);
        });
        if (parts.technicalPlan.contextUsed.filesAnalyzed.length > 10) {
          sections.push(`- ... and ${parts.technicalPlan.contextUsed.filesAnalyzed.length - 10} more`);
        }
      }
    }

    // Add best practices if provided
    if (parts.technicalPlan.bestPractices) {
      sections.push('');
      sections.push('#### ðŸ’¡ Industry Best Practices');
      sections.push('');
      sections.push(`> Source: ${parts.technicalPlan.bestPractices.perplexityModel}`);
      sections.push('');
      sections.push(parts.technicalPlan.bestPractices.bestPractices);
    }

    if (parts.technicalPlan.councilSummary) {
      sections.push('');
      sections.push(formatCouncilSummaryAsMarkdown(parts.technicalPlan.councilSummary));
    }

    sections.push('');
  }

  return sections.join('\n');
}

// ============================================
// Content-Only Formatters (without main headers)
// For use inside collapsible sections
// ============================================

/**
 * Format refinement content without the main H1 header
 * Used inside collapsible sections where the header is the section title
 */
export function formatRefinementContent(refinement: RefinementOutput): string {
  const sections: string[] = [];

  // Task Type Badge (no H1 header)
  const typeEmojis: Record<string, string> = {
    feature: 'âœ¨',
    bug: 'ðŸ›',
    enhancement: 'ðŸ”§',
    chore: 'ðŸ§¹',
  };
  sections.push(`**Type:** ${typeEmojis[refinement.taskType] || 'ðŸ“‹'} ${refinement.taskType.toUpperCase()}`);
  sections.push('');

  // Business Context
  if (refinement.businessContext) {
    sections.push('### Business Context');
    sections.push('');
    sections.push(refinement.businessContext);
    sections.push('');
  }

  // Objectives
  if (refinement.objectives && refinement.objectives.length > 0) {
    sections.push('### Objectives');
    sections.push('');
    refinement.objectives.forEach((objective, i) => {
      sections.push(`${i + 1}. ${objective}`);
    });
    sections.push('');
  }

  // Preliminary Acceptance Criteria
  if (refinement.preliminaryAcceptanceCriteria && refinement.preliminaryAcceptanceCriteria.length > 0) {
    sections.push('### Preliminary Acceptance Criteria');
    sections.push('');
    refinement.preliminaryAcceptanceCriteria.forEach((criterion, i) => {
      sections.push(`${i + 1}. ${criterion}`);
    });
    sections.push('');
  }

  // Questions for Product Owner
  if (refinement.questionsForPO && refinement.questionsForPO.length > 0) {
    sections.push('### â“ Questions for Product Owner');
    sections.push('');
    refinement.questionsForPO.forEach((question) => {
      sections.push(`- ${question}`);
    });
    sections.push('');
  }

  // Suggested Split
  if (refinement.suggestedSplit) {
    sections.push('### ðŸ”€ Suggested Split');
    sections.push('');
    sections.push(`**Reason:** ${refinement.suggestedSplit.reason}`);
    sections.push('');
    sections.push('**Proposed Stories:**');
    sections.push('');

    refinement.suggestedSplit.proposedStories.forEach((story, i) => {
      sections.push(`#### ${i + 1}. ${story.title}`);
      sections.push('');
      sections.push(story.description);
      sections.push('');

      if (story.dependencies && story.dependencies.length > 0) {
        sections.push('**Dependencies:**');
        story.dependencies.forEach((depIndex) => {
          const depTitle =
            refinement.suggestedSplit!.proposedStories[depIndex]?.title || `Subtask ${depIndex + 1}`;
          sections.push(`- Depends on: ${depTitle}`);
        });
        sections.push('');
      }

      if (story.acceptanceCriteria && story.acceptanceCriteria.length > 0) {
        sections.push('**Acceptance Criteria:**');
        story.acceptanceCriteria.forEach((criterion, idx) => {
          sections.push(`${idx + 1}. ${criterion}`);
        });
        sections.push('');
      }
    });
  }

  // Complexity Estimate
  const sizeEmojis: Record<string, string> = {
    XS: 'âšª',
    S: 'ðŸŸ¢',
    M: 'ðŸŸ¡',
    L: 'ðŸŸ ',
    XL: 'ðŸ”´',
  };
  sections.push('### Complexity Estimate');
  sections.push('');
  sections.push(`${sizeEmojis[refinement.complexityEstimate] || 'âšª'} **${refinement.complexityEstimate}** (T-shirt sizing)`);
  sections.push('');

  return sections.join('\n');
}

/**
 * Format user story content without the main H1 header
 * Used inside collapsible sections
 */
export function formatUserStoryContent(story: UserStoryGenerationOutput): string {
  const sections: string[] = [];

  // User Story Format (no H1 header)
  sections.push('### Story');
  sections.push('');
  sections.push(`**As a** ${story.userStory.actor},`);
  sections.push(`**I want** ${story.userStory.goal},`);
  sections.push(`**So that** ${story.userStory.benefit}.`);
  sections.push('');

  // Business Value
  if (story.businessValue) {
    sections.push('### Business Value');
    sections.push('');
    sections.push(story.businessValue);
    sections.push('');
  }

  // Acceptance Criteria
  if (story.acceptanceCriteria && story.acceptanceCriteria.length > 0) {
    sections.push('### Acceptance Criteria');
    sections.push('');
    story.acceptanceCriteria.forEach((criterion, i) => {
      sections.push(`${i + 1}. ${criterion}`);
    });
    sections.push('');
  }

  // Definition of Done
  if (story.definitionOfDone && story.definitionOfDone.length > 0) {
    sections.push('### Definition of Done');
    sections.push('');
    story.definitionOfDone.forEach((item) => {
      sections.push(`- ${item}`);
    });
    sections.push('');
  }

  // Story Points
  sections.push('### Estimated Complexity');
  sections.push('');
  sections.push(`**Story Points:** ${story.storyPoints} (Fibonacci scale)`);
  sections.push('');

  return sections.join('\n');
}

/**
 * Format technical plan content without the main H1 header
 * Used inside collapsible sections
 */
export function formatTechnicalPlanContent(plan: TechnicalPlanGenerationOutput): string {
  const sections: string[] = [];

  // Architecture Decisions (no H1 header)
  if (plan.architecture && plan.architecture.length > 0) {
    sections.push('### Architecture Decisions');
    sections.push('');
    plan.architecture.forEach((decision, i) => {
      sections.push(`${i + 1}. ${decision}`);
    });
    sections.push('');
  }

  // Files Affected
  if (plan.filesAffected && plan.filesAffected.length > 0) {
    sections.push('### Files to Modify');
    sections.push('');
    plan.filesAffected.forEach((file) => {
      sections.push(`- \`${file}\``);
    });
    sections.push('');
  }

  // Implementation Steps
  if (plan.implementationSteps && plan.implementationSteps.length > 0) {
    sections.push('### Implementation Steps');
    sections.push('');
    plan.implementationSteps.forEach((step, i) => {
      sections.push(`${i + 1}. ${step}`);
    });
    sections.push('');
  }

  // Technical Decisions
  if (plan.technicalDecisions && plan.technicalDecisions.length > 0) {
    sections.push('### Technical Decisions');
    sections.push('');
    plan.technicalDecisions.forEach((decision) => {
      sections.push(`- ${decision}`);
    });
    sections.push('');
  }

  // Dependencies
  if (plan.dependencies && plan.dependencies.length > 0) {
    sections.push('### Dependencies');
    sections.push('');
    plan.dependencies.forEach((dep) => {
      sections.push(`- ${dep}`);
    });
    sections.push('');
  }

  // Testing Strategy
  if (plan.testingStrategy) {
    sections.push('### Testing Strategy');
    sections.push('');
    sections.push(plan.testingStrategy);
    sections.push('');
  }

  // Risks & Considerations
  if (plan.risks && plan.risks.length > 0) {
    sections.push('### Risks & Considerations');
    sections.push('');
    plan.risks.forEach((risk) => {
      sections.push(`- âš ï¸ ${risk}`);
    });
    sections.push('');
  }

  // Estimated Time
  if (plan.estimatedTime) {
    sections.push('### Estimated Time');
    sections.push('');
    const hours = Math.floor(plan.estimatedTime / 60);
    const minutes = plan.estimatedTime % 60;
    if (hours > 0) {
      sections.push(`~${hours}h ${minutes > 0 ? `${minutes}m` : ''}`);
    } else {
      sections.push(`~${minutes}m`);
    }
    sections.push('');
  }

  return sections.join('\n');
}

// ============================================
// Standalone Document Formatters
// For Linear Documents linked to issues via issueId
// ============================================

/**
 * Format User Story as a standalone Linear Document
 * Used when storing User Story in a separate document linked to the issue
 * Phase 2 output
 */
export function formatUserStoryDocument(
  userStory: UserStoryGenerationOutput,
  council?: CouncilSummary
): string {
  const sections: string[] = [];

  // Header with DevFlow branding
  sections.push('# User Story');
  sections.push('');
  sections.push('> Generated by DevFlow - Phase 2: User Story');
  sections.push('');
  sections.push('---');
  sections.push('');

  // User Story Format
  sections.push('## Story');
  sections.push('');
  sections.push(`**As a** ${userStory.userStory.actor},`);
  sections.push(`**I want** ${userStory.userStory.goal},`);
  sections.push(`**So that** ${userStory.userStory.benefit}.`);
  sections.push('');

  // Business Value
  if (userStory.businessValue) {
    sections.push('---');
    sections.push('');
    sections.push('## Business Value');
    sections.push('');
    sections.push(userStory.businessValue);
    sections.push('');
  }

  // Acceptance Criteria
  if (userStory.acceptanceCriteria && userStory.acceptanceCriteria.length > 0) {
    sections.push('---');
    sections.push('');
    sections.push('## Acceptance Criteria');
    sections.push('');
    userStory.acceptanceCriteria.forEach((criterion, i) => {
      sections.push(`${i + 1}. ${criterion}`);
    });
    sections.push('');
  }

  // Definition of Done
  if (userStory.definitionOfDone && userStory.definitionOfDone.length > 0) {
    sections.push('---');
    sections.push('');
    sections.push('## Definition of Done');
    sections.push('');
    userStory.definitionOfDone.forEach((item) => {
      sections.push(`- [ ] ${item}`);
    });
    sections.push('');
  }

  // Story Points
  sections.push('---');
  sections.push('');
  sections.push('## Estimated Complexity');
  sections.push('');
  sections.push(`**Story Points:** ${userStory.storyPoints} (Fibonacci scale)`);
  sections.push('');

  // Council Summary if provided
  if (council) {
    sections.push('---');
    sections.push('');
    sections.push(formatCouncilSummaryAsMarkdown(council));
  }

  // Footer timestamp
  sections.push('---');
  sections.push('');
  sections.push(`*Generated at: ${new Date().toISOString()}*`);

  return sections.join('\n');
}

/**
 * Format Technical Plan as a standalone Linear Document
 * Used when storing Technical Plan in a separate document linked to the issue
 * Phase 3 output
 */
export function formatTechnicalPlanDocument(
  plan: TechnicalPlanGenerationOutput,
  contextUsed?: {
    language: string;
    framework?: string;
    dependencies: number;
    conventions: number;
    filesAnalyzed: string[];
    usingRAG: boolean;
  },
  council?: CouncilSummary,
  bestPractices?: {
    bestPractices: string;
    perplexityModel: string;
  }
): string {
  const sections: string[] = [];

  // Header with DevFlow branding
  sections.push('# Technical Plan');
  sections.push('');
  sections.push('> Generated by DevFlow - Phase 3: Technical Plan');
  sections.push('');
  sections.push('---');
  sections.push('');

  // Architecture Decisions
  if (plan.architecture && plan.architecture.length > 0) {
    sections.push('## Architecture Decisions');
    sections.push('');
    plan.architecture.forEach((decision, i) => {
      sections.push(`${i + 1}. ${decision}`);
    });
    sections.push('');
  }

  // Files Affected
  if (plan.filesAffected && plan.filesAffected.length > 0) {
    sections.push('---');
    sections.push('');
    sections.push('## Files to Modify');
    sections.push('');
    plan.filesAffected.forEach((file) => {
      sections.push(`- \`${file}\``);
    });
    sections.push('');
  }

  // Implementation Steps
  if (plan.implementationSteps && plan.implementationSteps.length > 0) {
    sections.push('---');
    sections.push('');
    sections.push('## Implementation Steps');
    sections.push('');
    plan.implementationSteps.forEach((step, i) => {
      sections.push(`${i + 1}. ${step}`);
    });
    sections.push('');
  }

  // Technical Decisions
  if (plan.technicalDecisions && plan.technicalDecisions.length > 0) {
    sections.push('---');
    sections.push('');
    sections.push('## Technical Decisions');
    sections.push('');
    plan.technicalDecisions.forEach((decision) => {
      sections.push(`- ${decision}`);
    });
    sections.push('');
  }

  // Dependencies
  if (plan.dependencies && plan.dependencies.length > 0) {
    sections.push('---');
    sections.push('');
    sections.push('## Dependencies');
    sections.push('');
    plan.dependencies.forEach((dep) => {
      sections.push(`- ${dep}`);
    });
    sections.push('');
  }

  // Testing Strategy
  if (plan.testingStrategy) {
    sections.push('---');
    sections.push('');
    sections.push('## Testing Strategy');
    sections.push('');
    sections.push(plan.testingStrategy);
    sections.push('');
  }

  // Risks & Considerations
  if (plan.risks && plan.risks.length > 0) {
    sections.push('---');
    sections.push('');
    sections.push('## Risks & Considerations');
    sections.push('');
    plan.risks.forEach((risk) => {
      sections.push(`- âš ï¸ ${risk}`);
    });
    sections.push('');
  }

  // Estimated Time
  if (plan.estimatedTime) {
    sections.push('---');
    sections.push('');
    sections.push('## Estimated Time');
    sections.push('');
    const hours = Math.floor(plan.estimatedTime / 60);
    const minutes = plan.estimatedTime % 60;
    if (hours > 0) {
      sections.push(`~${hours}h ${minutes > 0 ? `${minutes}m` : ''}`);
    } else {
      sections.push(`~${minutes}m`);
    }
    sections.push('');
  }

  // Best Practices section if provided
  if (bestPractices && bestPractices.bestPractices && bestPractices.bestPractices !== 'Unable to fetch best practices at this time.') {
    sections.push('---');
    sections.push('');
    sections.push('## ðŸŒ Best Practices (Perplexity)');
    sections.push('');
    sections.push(`> Source: ${bestPractices.perplexityModel}`);
    sections.push('');
    sections.push(bestPractices.bestPractices);
    sections.push('');
  }

  // Context Used section if provided
  if (contextUsed) {
    sections.push('---');
    sections.push('');
    sections.push('## ðŸ“Š Context Used');
    sections.push('');
    sections.push(`- **Language:** ${contextUsed.language}`);
    if (contextUsed.framework) {
      sections.push(`- **Framework:** ${contextUsed.framework}`);
    }
    sections.push(`- **Dependencies analyzed:** ${contextUsed.dependencies}`);
    sections.push(`- **Conventions found:** ${contextUsed.conventions}`);
    sections.push(`- **Files Analyzed:** ${contextUsed.filesAnalyzed?.length || 0}`);
    sections.push(`- **Using RAG:** ${contextUsed.usingRAG ? 'Yes' : 'No'}`);

    if (contextUsed.filesAnalyzed && contextUsed.filesAnalyzed.length > 0) {
      sections.push('');
      sections.push('**Referenced files:**');
      contextUsed.filesAnalyzed.slice(0, 15).forEach((file) => {
        sections.push(`- \`${file}\``);
      });
      if (contextUsed.filesAnalyzed.length > 15) {
        sections.push(`- ... and ${contextUsed.filesAnalyzed.length - 15} more`);
      }
    }
    sections.push('');
  }

  // Council Summary if provided
  if (council) {
    sections.push('---');
    sections.push('');
    sections.push(formatCouncilSummaryAsMarkdown(council));
  }

  // Footer timestamp
  sections.push('---');
  sections.push('');
  sections.push(`*Generated at: ${new Date().toISOString()}*`);

  return sections.join('\n');
}

/**
 * Format Best Practices as a standalone Linear Document
 * Used when storing Best Practices from Perplexity in a separate document linked to the issue
 * Fetched before Phase 3 (Technical Plan)
 */
export function formatBestPracticesDocument(
  bestPractices: {
    bestPractices: string;
    perplexityModel: string;
    sources?: string[];
  },
  taskContext?: {
    title: string;
    language?: string;
    framework?: string;
  }
): string {
  const sections: string[] = [];

  // Header with DevFlow branding
  sections.push('# Best Practices');
  sections.push('');
  sections.push('> Generated by DevFlow using Perplexity AI');
  sections.push('');
  sections.push('---');
  sections.push('');

  // Task context if provided
  if (taskContext) {
    sections.push('## Context');
    sections.push('');
    sections.push(`**Task:** ${taskContext.title}`);
    if (taskContext.language) {
      sections.push(`**Language:** ${taskContext.language}`);
    }
    if (taskContext.framework) {
      sections.push(`**Framework:** ${taskContext.framework}`);
    }
    sections.push('');
    sections.push('---');
    sections.push('');
  }

  // Best Practices content
  sections.push('## Recommendations');
  sections.push('');
  sections.push(bestPractices.bestPractices);
  sections.push('');

  // Sources if provided
  if (bestPractices.sources && bestPractices.sources.length > 0) {
    sections.push('---');
    sections.push('');
    sections.push('## Sources');
    sections.push('');
    bestPractices.sources.forEach((source, i) => {
      sections.push(`${i + 1}. ${source}`);
    });
    sections.push('');
  }

  // Footer with model info
  sections.push('---');
  sections.push('');
  sections.push(`*Model: ${bestPractices.perplexityModel}*`);
  sections.push(`*Generated at: ${new Date().toISOString()}*`);

  return sections.join('\n');
}

/**
 * Format Codebase Context as a standalone Linear Document
 * Contains top K RAG chunks with full code content
 * Created in Phase 1 (Refinement), reused in Phases 2 and 3
 */
export function formatCodebaseContextDocument(
  chunks: Array<{
    filePath: string;
    content: string;
    score: number;
    language: string;
    startLine?: number;
    endLine?: number;
    chunkType?: string;
  }>,
  taskContext?: {
    title: string;
    query: string;
  }
): string {
  const sections: string[] = [];

  // Header with DevFlow branding
  sections.push('# Codebase Context');
  sections.push('');
  sections.push('> Generated by DevFlow using RAG retrieval');
  sections.push('');
  sections.push('---');
  sections.push('');

  // Task context if provided
  if (taskContext) {
    sections.push('## Query');
    sections.push('');
    sections.push(`**Task:** ${taskContext.title}`);
    sections.push('');
    sections.push('---');
    sections.push('');
  }

  // Relevant Code sections
  sections.push('## Relevant Code');
  sections.push('');
  sections.push(`Found ${chunks.length} relevant code sections:`);
  sections.push('');

  chunks.forEach((chunk, i) => {
    sections.push(`### ${i + 1}. \`${chunk.filePath}\``);
    sections.push('');

    // Metadata line
    const metaParts = [`**Score:** ${(chunk.score * 100).toFixed(1)}%`, `**Language:** ${chunk.language}`];
    if (chunk.startLine && chunk.endLine) {
      metaParts.push(`**Lines:** ${chunk.startLine}-${chunk.endLine}`);
    }
    if (chunk.chunkType) {
      metaParts.push(`**Type:** ${chunk.chunkType}`);
    }
    sections.push(metaParts.join(' | '));
    sections.push('');

    // Code block
    sections.push('```' + chunk.language);
    sections.push(chunk.content);
    sections.push('```');
    sections.push('');
  });

  // Footer timestamp
  sections.push('---');
  sections.push('');
  sections.push(`*Retrieved at: ${new Date().toISOString()}*`);

  return sections.join('\n');
}

/**
 * Input type for documentation context document
 */
export interface DocumentationContextInput {
  projectStructure: {
    framework?: string;
    language: string;
    packageManager?: string;
    directories: string[];
    mainPaths: {
      src?: string;
      tests?: string;
      docs?: string;
      config?: string;
    };
  };
  dependencies: {
    production: Record<string, string>;
    dev: Record<string, string>;
    mainLibraries: string[];
  };
  documentation: {
    readme?: string;
    conventions: string[];
    patterns: string[];
  };
  relevantDocs?: Array<{
    filePath: string;
    content: string;
    score: number;
  }>;
  taskContext?: {
    title: string;
  };
}

/**
 * Format Documentation Context as a standalone Linear Document
 * Contains project configuration, technical stack, and relevant documentation
 * Created in Phase 1 (Refinement), reused in Phases 2 and 3
 */
export function formatDocumentationContextDocument(input: DocumentationContextInput): string {
  const sections: string[] = [];

  // Header with DevFlow branding
  sections.push('# Documentation Context');
  sections.push('');
  sections.push('> Generated by DevFlow - Project Analysis');
  sections.push('');
  sections.push('---');
  sections.push('');

  // Task context if provided
  if (input.taskContext) {
    sections.push(`**Task:** ${input.taskContext.title}`);
    sections.push('');
    sections.push('---');
    sections.push('');
  }

  // Project Configuration
  sections.push('## ðŸ—ï¸ Project Configuration');
  sections.push('');

  if (input.projectStructure.framework) {
    sections.push(`**Framework:** ${input.projectStructure.framework}`);
  }
  sections.push(`**Language:** ${input.projectStructure.language}`);
  if (input.projectStructure.packageManager) {
    sections.push(`**Package Manager:** ${input.projectStructure.packageManager}`);
  }
  sections.push('');

  // Main Paths
  const paths = input.projectStructure.mainPaths;
  if (paths.src || paths.tests || paths.docs || paths.config) {
    sections.push('### Main Paths');
    sections.push('');
    if (paths.src) sections.push(`- **Source:** ${paths.src}`);
    if (paths.tests) sections.push(`- **Tests:** ${paths.tests}`);
    if (paths.docs) sections.push(`- **Docs:** ${paths.docs}`);
    if (paths.config) sections.push(`- **Config:** ${paths.config}`);
    sections.push('');
  }

  // Directories
  if (input.projectStructure.directories.length > 0) {
    sections.push('### Project Structure');
    sections.push('');
    input.projectStructure.directories.slice(0, 15).forEach((dir) => {
      sections.push(`- \`${dir}\``);
    });
    if (input.projectStructure.directories.length > 15) {
      sections.push(`- ... and ${input.projectStructure.directories.length - 15} more`);
    }
    sections.push('');
  }

  sections.push('---');
  sections.push('');

  // Technical Stack
  sections.push('## ðŸ“¦ Technical Stack');
  sections.push('');

  // Main Libraries summary
  if (input.dependencies.mainLibraries.length > 0) {
    sections.push(`**Main Libraries:** ${input.dependencies.mainLibraries.join(', ')}`);
    sections.push('');
  }

  // Production Dependencies
  const prodDeps = Object.entries(input.dependencies.production);
  if (prodDeps.length > 0) {
    sections.push('### Production Dependencies');
    sections.push('');
    prodDeps.slice(0, 20).forEach(([name, version]) => {
      sections.push(`- \`${name}\`: ${version}`);
    });
    if (prodDeps.length > 20) {
      sections.push(`- ... and ${prodDeps.length - 20} more`);
    }
    sections.push('');
  }

  // Dev Dependencies
  const devDeps = Object.entries(input.dependencies.dev);
  if (devDeps.length > 0) {
    sections.push('### Dev Dependencies');
    sections.push('');
    devDeps.slice(0, 10).forEach(([name, version]) => {
      sections.push(`- \`${name}\`: ${version}`);
    });
    if (devDeps.length > 10) {
      sections.push(`- ... and ${devDeps.length - 10} more`);
    }
    sections.push('');
  }

  sections.push('---');
  sections.push('');

  // Documentation section
  sections.push('## ðŸ“– Relevant Documentation');
  sections.push('');

  // README excerpt
  if (input.documentation.readme) {
    sections.push('### From README');
    sections.push('');
    // Truncate long READMEs
    const readmeExcerpt = input.documentation.readme.length > 1000
      ? input.documentation.readme.substring(0, 1000) + '...'
      : input.documentation.readme;
    sections.push('> ' + readmeExcerpt.split('\n').join('\n> '));
    sections.push('');
  }

  // Conventions
  if (input.documentation.conventions.length > 0) {
    sections.push('### Conventions');
    sections.push('');
    input.documentation.conventions.forEach((convention) => {
      sections.push(`- ${convention}`);
    });
    sections.push('');
  }

  // Patterns
  if (input.documentation.patterns.length > 0) {
    sections.push('### Architectural Patterns');
    sections.push('');
    input.documentation.patterns.forEach((pattern) => {
      sections.push(`- ${pattern}`);
    });
    sections.push('');
  }

  // Relevant Docs from RAG
  if (input.relevantDocs && input.relevantDocs.length > 0) {
    sections.push('### Related Docs (RAG)');
    sections.push('');
    input.relevantDocs.forEach((doc, i) => {
      sections.push(`#### ${i + 1}. \`${doc.filePath}\` (score: ${(doc.score * 100).toFixed(0)}%)`);
      sections.push('');
      // Truncate long content
      const excerpt = doc.content.length > 500
        ? doc.content.substring(0, 500) + '...'
        : doc.content;
      sections.push('> ' + excerpt.split('\n').join('\n> '));
      sections.push('');
    });
  }

  // Footer timestamp
  sections.push('---');
  sections.push('');
  sections.push(`*Generated at: ${new Date().toISOString()}*`);

  return sections.join('\n');
}

// ============================================
// External Context Document Formatters
// For Figma, Sentry, and GitHub Issue contexts
// ============================================

/**
 * Input type for Figma context document
 */
export interface FigmaContextDocumentInput {
  fileKey: string;
  fileName: string;
  lastModified?: string;
  thumbnailUrl?: string;
  comments?: Array<{
    id: string;
    message: string;
    user: { handle: string };
    created_at: string;
    resolved_at?: string;
  }>;
  screenshots?: Array<{
    nodeId: string;
    nodeName: string;
    imageUrl?: string;
    visionAnalysis?: string;
  }>;
  taskContext?: { title: string; identifier: string };
}

/**
 * Format Figma context as a standalone Linear Document
 * Contains file metadata, design comments, and AI-analyzed screenshots
 * Created in Phase 1 (Refinement)
 */
export function formatFigmaContextDocument(input: FigmaContextDocumentInput): string {
  const sections: string[] = [];

  // Header with DevFlow branding
  sections.push('# ðŸŽ¨ Figma Design Context');
  sections.push('');
  sections.push('> Generated by DevFlow - Design Analysis');
  sections.push('');
  sections.push('---');
  sections.push('');

  // Task context if provided
  if (input.taskContext) {
    sections.push(`**Issue:** ${input.taskContext.identifier} - ${input.taskContext.title}`);
    sections.push('');
    sections.push('---');
    sections.push('');
  }

  // File metadata
  sections.push('## ðŸ“„ File Information');
  sections.push('');
  sections.push(`**File:** ${input.fileName}`);
  sections.push(`**File Key:** \`${input.fileKey}\``);
  if (input.lastModified) {
    sections.push(`**Last Modified:** ${input.lastModified}`);
  }
  if (input.thumbnailUrl) {
    sections.push(`**Thumbnail:** [View](${input.thumbnailUrl})`);
  }
  sections.push('');

  // Design comments
  if (input.comments && input.comments.length > 0) {
    sections.push('---');
    sections.push('');
    sections.push('## ðŸ’¬ Design Comments');
    sections.push('');

    input.comments.forEach((comment, idx) => {
      const status = comment.resolved_at ? 'âœ… Resolved' : 'ðŸ’¬ Open';
      sections.push(`### ${idx + 1}. ${status}`);
      sections.push('');
      sections.push(`**Author:** ${comment.user.handle}`);
      sections.push(`**Date:** ${comment.created_at}`);
      sections.push('');
      sections.push(`> ${comment.message}`);
      sections.push('');
    });
  }

  // Screenshots with analysis
  if (input.screenshots && input.screenshots.length > 0) {
    sections.push('---');
    sections.push('');
    sections.push('## ðŸ“¸ Screenshots & Analysis');
    sections.push('');

    input.screenshots.forEach((screenshot, idx) => {
      sections.push(`### ${idx + 1}. ${screenshot.nodeName}`);
      sections.push('');
      sections.push(`**Node ID:** \`${screenshot.nodeId}\``);
      if (screenshot.imageUrl) {
        sections.push(`**Image:** [View](${screenshot.imageUrl})`);
      }
      if (screenshot.visionAnalysis) {
        sections.push('');
        sections.push('**AI Design Analysis:**');
        sections.push('');
        sections.push(screenshot.visionAnalysis);
      }
      sections.push('');
    });
  }

  // Footer timestamp
  sections.push('---');
  sections.push('');
  sections.push(`*Generated at: ${new Date().toISOString()}*`);

  return sections.join('\n');
}

/**
 * Input type for Sentry context document
 */
export interface SentryContextDocumentInput {
  issueId: string;
  shortId: string;
  title: string;
  culprit?: string;
  level: string;
  status: string;
  platform?: string;
  count: number;
  userCount: number;
  firstSeen?: string;
  lastSeen?: string;
  project?: {
    id: string;
    name: string;
    slug: string;
  };
  errorType?: string;
  errorMessage?: string;
  stacktrace?: {
    frames: Array<{
      filename: string;
      function: string;
      lineNo: number;
      colNo?: number;
      context?: string[];
    }>;
  };
  tags?: Array<{ key: string; value: string }>;
  taskContext?: { title: string; identifier: string };
}

/**
 * Format Sentry context as a standalone Linear Document
 * Contains issue details, stacktrace, and error information
 * Created in Phase 1 (Refinement)
 */
export function formatSentryContextDocument(input: SentryContextDocumentInput): string {
  const sections: string[] = [];

  // Header with DevFlow branding
  sections.push('# ðŸ› Sentry Error Context');
  sections.push('');
  sections.push('> Generated by DevFlow - Error Analysis');
  sections.push('');
  sections.push('---');
  sections.push('');

  // Task context if provided
  if (input.taskContext) {
    sections.push(`**Issue:** ${input.taskContext.identifier} - ${input.taskContext.title}`);
    sections.push('');
    sections.push('---');
    sections.push('');
  }

  // Issue overview
  sections.push('## ðŸ“Š Issue Overview');
  sections.push('');
  sections.push(`**Sentry Issue:** ${input.shortId} - ${input.title}`);

  const levelEmoji: Record<string, string> = {
    fatal: 'ðŸ’€',
    error: 'âŒ',
    warning: 'âš ï¸',
    info: 'â„¹ï¸',
    debug: 'ðŸ”',
  };

  sections.push(`**Level:** ${levelEmoji[input.level] || 'â“'} ${input.level.toUpperCase()} | **Status:** ${input.status}`);

  if (input.platform) {
    sections.push(`**Platform:** ${input.platform}`);
  }
  if (input.project) {
    sections.push(`**Project:** ${input.project.name} (\`${input.project.slug}\`)`);
  }

  sections.push(`**Occurrences:** ${input.count.toLocaleString()} | **Users Affected:** ${input.userCount.toLocaleString()}`);

  if (input.firstSeen) {
    sections.push(`**First Seen:** ${input.firstSeen}`);
  }
  if (input.lastSeen) {
    sections.push(`**Last Seen:** ${input.lastSeen}`);
  }
  sections.push('');

  // Error details
  if (input.errorType || input.errorMessage || input.culprit) {
    sections.push('---');
    sections.push('');
    sections.push('## âŒ Error Details');
    sections.push('');
    if (input.errorType) {
      sections.push(`**Type:** \`${input.errorType}\``);
    }
    if (input.errorMessage) {
      sections.push(`**Message:** ${input.errorMessage}`);
    }
    if (input.culprit) {
      sections.push(`**Culprit:** \`${input.culprit}\``);
    }
    sections.push('');
  }

  // Stacktrace
  if (input.stacktrace && input.stacktrace.frames.length > 0) {
    sections.push('---');
    sections.push('');
    sections.push('## ðŸ“š Stacktrace');
    sections.push('');
    sections.push('```');

    // Show top 15 frames (most relevant)
    input.stacktrace.frames.slice(0, 15).forEach((frame) => {
      const location = frame.colNo
        ? `${frame.filename}:${frame.lineNo}:${frame.colNo}`
        : `${frame.filename}:${frame.lineNo}`;
      sections.push(`at ${frame.function} (${location})`);
    });

    if (input.stacktrace.frames.length > 15) {
      sections.push(`... and ${input.stacktrace.frames.length - 15} more frames`);
    }

    sections.push('```');
    sections.push('');
  }

  // Tags
  if (input.tags && input.tags.length > 0) {
    sections.push('---');
    sections.push('');
    sections.push('## ðŸ·ï¸ Tags');
    sections.push('');
    sections.push('| Key | Value |');
    sections.push('|-----|-------|');

    input.tags.slice(0, 15).forEach((tag) => {
      // Escape pipe characters in values
      const safeValue = tag.value.replace(/\|/g, '\\|');
      sections.push(`| ${tag.key} | ${safeValue} |`);
    });

    if (input.tags.length > 15) {
      sections.push('');
      sections.push(`*... and ${input.tags.length - 15} more tags*`);
    }
    sections.push('');
  }

  // Footer timestamp
  sections.push('---');
  sections.push('');
  sections.push(`*Generated at: ${new Date().toISOString()}*`);

  return sections.join('\n');
}

/**
 * Input type for GitHub Issue context document
 */
export interface GitHubIssueContextDocumentInput {
  id: string;
  number: number;
  title: string;
  state: string;
  body?: string;
  author: string;
  url: string;
  labels?: string[];
  assignees?: string[];
  createdAt: string;
  updatedAt?: string;
  closedAt?: string;
  comments?: Array<{
    id: string;
    author: string;
    body: string;
    createdAt: string;
  }>;
  taskContext?: { title: string; identifier: string };
}

/**
 * Format GitHub Issue context as a standalone Linear Document
 * Contains issue details, body, labels, and discussion
 * Created in Phase 1 (Refinement)
 */
export function formatGitHubIssueContextDocument(input: GitHubIssueContextDocumentInput): string {
  const sections: string[] = [];

  // Header with DevFlow branding
  sections.push('# ðŸ“‹ GitHub Issue Context');
  sections.push('');
  sections.push('> Generated by DevFlow - Issue Analysis');
  sections.push('');
  sections.push('---');
  sections.push('');

  // Task context if provided
  if (input.taskContext) {
    sections.push(`**Linear Issue:** ${input.taskContext.identifier} - ${input.taskContext.title}`);
    sections.push('');
    sections.push('---');
    sections.push('');
  }

  // Issue metadata
  sections.push('## ðŸ“„ Issue Information');
  sections.push('');
  sections.push(`**Issue:** [#${input.number} - ${input.title}](${input.url})`);

  const stateEmoji = input.state === 'open' ? 'ðŸŸ¢' : 'ðŸ”´';
  sections.push(`**State:** ${stateEmoji} ${input.state.charAt(0).toUpperCase() + input.state.slice(1)}`);
  sections.push(`**Author:** @${input.author}`);
  sections.push(`**Created:** ${input.createdAt}`);

  if (input.updatedAt) {
    sections.push(`**Updated:** ${input.updatedAt}`);
  }
  if (input.closedAt) {
    sections.push(`**Closed:** ${input.closedAt}`);
  }
  sections.push('');

  // Labels
  if (input.labels && input.labels.length > 0) {
    sections.push(`**Labels:** ${input.labels.map(l => `\`${l}\``).join(', ')}`);
    sections.push('');
  }

  // Assignees
  if (input.assignees && input.assignees.length > 0) {
    sections.push(`**Assignees:** ${input.assignees.map(a => `@${a}`).join(', ')}`);
    sections.push('');
  }

  // Issue body
  if (input.body && input.body.trim()) {
    sections.push('---');
    sections.push('');
    sections.push('## ðŸ“ Issue Description');
    sections.push('');
    sections.push(input.body);
    sections.push('');
  }

  // Comments
  if (input.comments && input.comments.length > 0) {
    sections.push('---');
    sections.push('');
    sections.push(`## ðŸ’¬ Discussion (${input.comments.length} comments)`);
    sections.push('');

    // Show first 10 comments
    input.comments.slice(0, 10).forEach((comment, idx) => {
      sections.push(`### Comment ${idx + 1} - @${comment.author}`);
      sections.push(`*${comment.createdAt}*`);
      sections.push('');
      // Truncate very long comments
      const commentBody = comment.body.length > 1000
        ? comment.body.substring(0, 1000) + '...'
        : comment.body;
      sections.push(commentBody);
      sections.push('');
    });

    if (input.comments.length > 10) {
      sections.push(`*... and ${input.comments.length - 10} more comments*`);
      sections.push('');
    }
  }

  // Footer timestamp
  sections.push('---');
  sections.push('');
  sections.push(`*Generated at: ${new Date().toISOString()}*`);

  return sections.join('\n');
}
